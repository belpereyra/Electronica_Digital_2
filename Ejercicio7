typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

// Registros de control del reloj (RCC)
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define APB2ENR *(volatile int*)0x40021018

// Puerto B
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C // lee y escribe en pines de salida
#define GPIOB_IDR *(volatile int*)0x40010C08 // lee y escribe en pines de entrada

// Registros del SysTick.
#define SYSTICK_CSR  *(volatile int*)0xE000E010 // habilitar, deshabilitar y verificar el estado del temporizador
#define SYSTICK_RVR  *(volatile int*)0xE000E014 // almacena el valor desde el cual el temporizador SysTick comenzará a contar hacia abajo.
#define SYSTICK_CVR  *(volatile int*)0xE000E018 // almacena el valor actual del contador.
#define SYSTICK_CALIB  *(volatile int*)0xE000E01C // Registro de Valor Actual.
#define SYST_CSR_ENABLE    (1u<<0) //enable en 1
#define SYST_CSR_CLKSOURCE (1u<<2) // clk en 1
#define SYST_CSR_COUNTFLAG (1u<<16) // countflag en 1

// Definición del pin del LED
#define LED_PIN 13


int main(void)
{

	APB2ENR |= (1 << 3); // Enable GPIOB clock 

	GPIOB_CRL  = 0x33333333;            // Make low GPIOB output
	GPIOB_CRH  = 0x33333333;            // Make high GPIOB output		

	// Arranca apagado
	GPIOB_ODR |= (1u << LED_PIN);
    
    // Configurar el SysTick para un retardo de 0.5 segundos.
    SYSTICK_RVR = 35999999; // (72MHz / 2) - 1
    SYSTICK_CVR = 0; // Reiniciar el contador actual
    
    // Habilitar el SysTick y configurar la fuente del reloj (AHB).
    SYSTICK_CSR = SYST_CSR_ENABLE | SYST_CSR_CLKSOURCE;


	for(;;)
	{
         // Polling: Revisar estado del contador. Espera hasta que el SysTick termine de contar.
        // El bit 16 de SYSTICK_CSR (COUNTFLAG) se pone en 1 cuando el contador llega a 0.
        if (SYSTICK_CSR & SYST_CSR_COUNTFLAG)
        {
            // Invierte el estado del pin PB13 para que el LED parpadee.
            GPIOB_ODR ^= (1u << LED_PIN);

        }

	}

	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)		
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// 0x0000_0000 Stack Pointer
	(interrupt_t) main,										// 0x0000_0004 Reset
};
