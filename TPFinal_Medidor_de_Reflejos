typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

// Variables para la lógica
volatile uint32_t ms_count = 0; // Para contar tiempo

// RCC
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define APB2ENR *(volatile int*)0x40021018

// PUERTO A
#define GPIOA_CRL *(volatile int*)0x40010800
#define GPIOA_CRH *(volatile int*)0x40010804
#define GPIOA_ODR *(volatile int*)0x4001080C// lee y escribe en pines de salida -> no lo uso
#define GPIOA_IDR *(volatile int*)0x40010808 // lee y escribe en pines de entrada

// PUERTO B
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C // lee y escribe en pines de salida
#define GPIOB_IDR *(volatile int*)0x40010C08 // lee y escribe en pines de entrada -> no lo uso

// SYSTICK
#define SYSTICK_CSR  *(volatile int*)0xE000E010 // habilitar, deshabilitar y verificar el estado del temporizador
#define SYSTICK_RVR  *(volatile int*)0xE000E014 // almacena el valor desde el cual el temporizador SysTick comenzará a contar hacia abajo.
#define SYSTICK_CVR  *(volatile int*)0xE000E018 // almacena el valor actual del contador.
#define SYSTICK_CALIB  *(volatile int*)0xE000E01C // Registro de Valor Actual.

// Timer (cada 1ms)
void SysTick_Handler(void) 
{
	ms_count++;
}

int main(void)
{

	// 1. Relojes
	APB2ENR |= (1 << 2) | (1 << 3); // Enable GPIOA y GPIOB clock

	// 2. Configuracion GPIO
	// a) GPIOB como salida push-pull
	GPIOB_CRL  = 0x33333333;            // Make low GPIOB output (PB0, PB1, PB5)
	GPIOB_CRH  = 0x33333333;            // Make high GPIOB output -> no lo uso
	GPIOB_ODR &= ~((1<<0) | (1<<1) | (1<<10)); // Asegurar que todo arranca apagado	
	
	// b) GPIOA como entrada pull-up
	// 0x8 en binario -> 1000 (Mode=00 Input, CNF=10 Pull-up/down)
	GPIOA_CRL  = 0x88888888;            // Make low GPIOA input 
	GPIOA_CRH  = 0x88888888;            // Make high GPIOA input -> no lo uso
	GPIOA_ODR |= (1 << 0);              // Activar Pull-Up en PA0 

	// 3. Configuración del Systick
	// Genera una interrupción cada 1ms
	SYSTICK_RVR = 7999;  // (8000 - 1)
    SYSTICK_CVR = 0;     // Reiniciar contador
	SYSTICK_CSR = 0x07; // 1 | 2 | 4 = 7 -> 0x07
							// Bit 0: ENABLE (1)
							// Bit 1: TICKINT (1) -> Habilita la interrupción
							// Bit 2: CLKSOURCE (1) -> Reloj del procesador: 72MHz

	uint32_t tiempo_inicio; // Almacena el tiempo en que se encendio el LED
	uint32_t tiempo_reaccion; // diferencia entre el tiempo que estuve encendido el LED y lo que tardo el usuario en alertarlo
	uint32_t espera_random; // Almacena un tiempo de espera aleatorio
	uint32_t ultimo_cambio = 0; // Para recordar cuándo cambiaron las luces
    uint8_t estado_leds = 0;    // 0 = Apagados, 1 = Encendidos
	uint8_t paso_secuencia = 0; // 0=Rojo, 1=Verde, 2=Amarillo

	// Parpadeo de luces hasta que el usuario inicie con el test (pulse el botón)
	while((GPIOA_IDR & (1 << 0)) != 0)
    {
        // Verificar si pasaron 200ms
        if ((ms_count - ultimo_cambio) > 300) // Aca vario la velocidad de parpadeo
        {
            ultimo_cambio = ms_count; // Actualizar reloj

            GPIOB_ODR &= ~((1 << 0) | (1 << 1) | (1 << 10)); // Se apagan todos los LEDs

            // Se prende el LED que toca segun el paso
            if (paso_secuencia == 0) {
                GPIOB_ODR |= (1 << 0); // Prende Rojo
            }
            else if (paso_secuencia == 1) {
                GPIOB_ODR |= (1 << 1); // Prende Verde
            }
            else if (paso_secuencia == 2) {
                GPIOB_ODR |= (1 << 10); 
            }

            paso_secuencia++; // Avanza por cada LED
            
            // Retorna al 0 cuando paso_secuencia++ > 2
            if (paso_secuencia > 2) {
                paso_secuencia = 0;
            }
        }
    }

	// Aseguramos que todo quede apagado antes de empezar
    GPIOB_ODR &= ~((1 << 0) | (1 << 1) | (1 << 10));

	while(1)
	{
		// 1. Apagar LEDs
		GPIOB_ODR &= ~((1<<0) | (1<<1) | (1<<10)); // Apagar puerto B en uso

		// 2. Espera aleatoria
		espera_random = (ms_count % 4000) + 1000; // Entre 4 y casi 10 segundos
			/* ms_count es una variable contador que aumenta cada 1ms debido al Systick. La variable tendra un valor diferente en cada
				pulsada debido al error humano de no tocar el boton siempre con el mismo retardo.
				Se divide por 4000 y se toma el resto, el cual será entre 0 y 4999. Para evitar que el valor de espera sea 0,
				se suman 1000 ms (4 segundos).*/
		
		// 3. Esperar 
        tiempo_inicio = ms_count; 
        while((ms_count - tiempo_inicio) < espera_random); 

		// 4. Encender estimulo (LED rojo PB0)
		GPIOB_ODR |= (1 << 0); // Se pone en 1 PB0
		tiempo_inicio = ms_count; // se almcaena el momento en que se prendió el LED

		// 5. Esperar a que se presione el botón (POLLING)
		// Esperar mientras PA0 sea 1 (No presionado)
        while ((GPIOA_IDR & (1 << 0)) != 0); // Al presionar el boton el pin se conecta a tierra y se lee 0

		// 6. Resultados
		tiempo_reaccion = ms_count - tiempo_inicio; // Se resta el valor actual del contador con el tiempo en el que se registró el encendido
		GPIOB_ODR &= ~(1 << 0); // Apagar rojo

		if (tiempo_reaccion < 250)
        {
            GPIOB_ODR |= (1 << 1); // VERDE (PB1) -> Rápido
        }
        else 
        {
            GPIOB_ODR |= (1 << 10); // AMARILLO (PB5) - Lento
        }

		// 6. Visualización de los resultados
		tiempo_inicio = ms_count;
        while((ms_count - tiempo_inicio) < 2000); // Ver luz por 2 segundos
	}		
	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

// Tabla de vectores de interrupción: Primer bloque de memoria que lee el procesador al iniciar, esta al comienzo del Flash.
// Vector tables es un arreglo de punteros a funciones.
#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
    STACKINIT,              // 0: Stack Pointer
    (interrupt_t)main,      // 1: Reset
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // Relleno
    [15] = SysTick_Handler  // 15: SysTick
};
