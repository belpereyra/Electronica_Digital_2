typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

// Registros de control del reloj (RCC)
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define APB2ENR *(volatile int*)0x40021018

// Puerto B
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C // lee y escribe en pines de salida
#define GPIOB_IDR *(volatile int*)0x40010C08 // lee y escribe en pines de entrada

// Registros del SysTick.
#define SYSTICK_CSR  *(volatile int*)0xE000E010 // habilitar, deshabilitar y verificar el estado del temporizador
#define SYSTICK_RVR  *(volatile int*)0xE000E014 // almacena el valor desde el cual el temporizador SysTick comenzará a contar hacia abajo.
#define SYSTICK_CVR  *(volatile int*)0xE000E018 // almacena el valor actual del contador.
#define SYST_CALIB   *(volatile int*)0xE000E01C

// Dentro del registro CSR
#define SYST_CSR_ENABLE    (1u<<0) //enable en 1 habilita el contador
#define SYST_CSR_TICKINT    (1u << 1) // Habilita interrupción
#define SYST_CSR_CLKSOURCE (1u<<2) // clk en 1 (usa reloj del procesador)

volatile uint32_t systick_counter = 0; // contador global

// Definición del pin del LED
#define LED_PIN 13

void delay_ms(uint32_t ms);
void SysTick_Handler(void);

int main(void)
{

	APB2ENR |= (1 << 3); // Enable GPIOB clock 

    // Salida push pull
	GPIOB_CRL  = 0x33333333;            // Make low GPIOB output
	GPIOB_CRH  = 0x33333333;            // Make high GPIOB output		

	// Arranca apagado
	GPIOB_ODR |= (1u << LED_PIN);

    // Leer el valor de calibración para 10ms.
    uint32_t tenms_value = SYST_CALIB;
    
    // Se lee el valor TENMS (bits 23:0).
    uint32_t reload_value = (tenms_value & 0x00FFFFFF);

    // Configurar el SysTick para el valor calibrado.
    SYSTICK_RVR = reload_value;

    // Limpia el contador actual.
    SYSTICK_CVR = 0;
    
    // Configuración de temporizador e interrupción
    // Habilitar el SysTick con interrupción y configurar la fuente del reloj (AHB).
    SYSTICK_CSR = SYST_CSR_ENABLE | SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT; // CSR registro que hablita y deshabilita el Systick
        // SYST_CSR_ENABLE → Activa el temporizador (empieza a contar). Sin este no cuenta.
        // SYST_CSR_TICKINT → Habilita la interrupción del SysTick al llegar a cero (llama a SysTick_Handler()). Sin este cuenta pero no se genera interrupcion.
        // SYST_CSR_CLKSOURCE → Selecciona como fuente de reloj el reloj del sistema (AHB = 72 MHz). Sin este, cuenta lento.

    
    for(;;)
	{
        GPIOB_ODR ^= (1<<13);  
        delay_ms(1000);         // Espera 1000 ms
    }

	return 0;
}

void delay_ms(uint32_t ms)
{
    systick_counter = ms;
    while (systick_counter != 0); // espera bloqueante
}

void SysTick_Handler(void)
{
    if (systick_counter > 0)
        systick_counter--; // se decrementa cada 1ms
}

#define SRAM_SIZE ((uint32_t) 0x00005000)		
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

// Tabla de vectores de interrupción: Primer bloque de memoria que lee el procesador al iniciar, esta al comienzo del Flash.
// Vector tables es un arreglo de punteros a funciones.
typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// Pos0. 0x0000_0000 Stack Pointer -> Valor inicial de donde arranca a leer el micro(pos 0 de la Flash)
	(interrupt_t) main,										// Pos1. 0x0000_0004 Reset

    // Posiciones 2 a 14 sin usar
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                  // Pos2-14. Sin usar

    // Posición 15: SysTick Handler
    [15] = SysTick_Handler,
};
