/*Implementar un código en C para configurar el reloj del sistema de la siguiente manera:
Fuente de reloj : PLL
Oscilador : HSE
Factor multiplicador del PLL : 4
Prescaler del HSE (PLLXTPRE) : 2
Prescaler del AHB : 2
Prescaler del APB1 : 2
Prescaler del APB2 : 4

Indicar las frecuencias de reloj de:
Los periféricos conectados al bus APB1
Los timers conectados al bus APB1
Los periféricos conectados al bus APB2
Los timers conectados al bus APB2
*/

typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

// Registro GPIOC
#define APB2ENR *(volatile int*)0x40021018
#define CRL *(volatile int*)0x40011000
#define CRH *(volatile int*)0x40011004
#define ODR *(volatile int*)0x4001100C

// Registros clk
#define RCC_CR *(volatile int*)0x40021000
#define RCC_CFGR *(volatile int*)0x40021004
#define RCC_CIR *(volatile int*)0x40021008
#define RCC_APB2RSTR *(volatile int*)0x4002100C
#define RCC_APB1RSTR *(volatile int*)0x40021010
#define RCC_AHBENR *(volatile int*)0x40021014
#define RCC_APB2ENR *(volatile int*)0x40021018
#define RCC_APB1ENR *(volatile int*)0x4002101C

// Registro FLASH		
#define FLASH_ACR *(volatile uint32_t*)0x40022000

int main(void)
{
	// 1. Habilitar HSE (Oscilador externo de alta velocidad)
	RCC_CR |= (1 << 16);	//Habilitacion del HSE 
	while (!(RCC_CR & (1<<17)));  // Esperar hasta que el HSE este listo
	
	// 2. Configurar la latencia de la Flash
	// SYSCLK = (8MHz / 2) * 4 = 16 MHz
	FLASH_ACR &= ~(0x7); // Limpiar bits 
	
	// 3. Configurar Prescalers 
    // HCLK (AHB) = SYSCLK / 2
	RCC_CFGR |= (0b0100 << 4); // Establecer el multiplicador del PLL en 4

	// PCLK1 (APB1) = HCLK / 2
    RCC_CFGR |= (0b100 << 8);

	// PCLK2 (APB2) = HCLK / 4
    RCC_CFGR |= (0b101 << 11);

	// 4. Configurar el PLL
	RCC_CFGR |= (1 << 16); // Seleccionar el HSE como fuente de reloj del PLL

	// Prescaler HSE = 2
    RCC_CFGR |= (1 << 17);

	// Multiplicador PLL = 4
    // (8MHz / 2) * 4 = 16 MHz
    RCC_CFGR |= (0b0010 << 18);

	// 5. Habilitar el PLL
    RCC_CR |= (1 << 24);
	while (!(RCC_CR & (1 << 25))); // Esperar hasta que el PLL esté listo

	// 6. Seleccionar el PLL como fuente de reloj del sistema (SYSCLK)
    RCC_CFGR |= (0b10 << 0);
	while ((RCC_CFGR & (0b11 << 2)) != (0b10 << 2)); // esperar a que este listo

    for(;;)
    return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
    STACKINIT,                                              // 0x0000_0000 Stack Pointer
    (interrupt_t) main,                                     // 0x0000_0004 Reset
};
