typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

volatile uint32_t ms_count = 0; // Variable para contar tiempo

// RCC
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define APB2ENR *(volatile int*)0x40021018

// PUERTO A
#define GPIOA_CRL *(volatile int*)0x40010800
#define GPIOA_CRH *(volatile int*)0x40010804
#define GPIOA_ODR *(volatile int*)0x4001080C// lee y escribe en pines de salida -> no lo uso
#define GPIOA_IDR *(volatile int*)0x40010808 // lee y escribe en pines de entrada

// PUERTO B
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C // lee y escribe en pines de salida
#define GPIOB_IDR *(volatile int*)0x40010C08 // lee y escribe en pines de entrada -> no lo uso

// SYSTICK
#define SYSTICK_CSR  *(volatile int*)0xE000E010 // habilitar, deshabilitar y verificar el estado del temporizador
#define SYSTICK_RVR  *(volatile int*)0xE000E014 // almacena el valor desde el cual el temporizador SysTick comenzará a contar hacia abajo.
#define SYSTICK_CVR  *(volatile int*)0xE000E018 // almacena el valor actual del contador.
#define SYSTICK_CALIB  *(volatile int*)0xE000E01C // Registro de Valor Actual.
#define SYST_CSR_ENABLE    (1u<<0) //enable en 1
#define SYST_CSR_CLKSOURCE (1u<<2) // clk en 1
#define SYST_CSR_COUNTFLAG (1u<<16) // countflag en 1

// Manejo de interrupción de tiempo (cada 1ms)
void SysTick_Handler(void) 
{
	ms_count++;
}

int main(void)
{

	APB2ENR |= (1 << 2) | (1 << 3); // Enable GPIOA y GPIOB clock

	// GPIOB como salida push-pull
	GPIOB_CRL  = 0x33333333;            // Make low GPIOB output
	GPIOB_CRH  = 0x33333333;            // Make high GPIOB output
	GPIOB_ODR &= ~(0xFFFF); 			// Asegurar que todo arranca apagado	
	
	// GPIOA como entrada pull-up
	// 0x8 en binario -> 1000 (Mode=00 Input, CNF=10 Pull-up/down)
	GPIOA_CRL  = 0x88888888;            // Make low GPIOC input
	GPIOA_CRH  = 0x88888888;            // Make high GPIOC input
	GPIOA_ODR |= (1 << 0);              // Activar Pull-Up en PA0

	// Configurar el SysTick para un retardo de 0.5 segundos.
    SYSTICK_RVR = 7999; 
    SYSTICK_CVR = 0; // Reiniciar el contador actual
	SYSTICK_CSR = 0x07; // 1 | 2 | 4 = 7 -> 0x07
						// Bit 0: ENABLE (1)
    					// Bit 1: TICKINT (1) -> Habilita la interrupción
    					// Bit 2: CLKSOURCE (1) -> Reloj del procesador
	
	// Variables para la lógica
    uint32_t tiempo_inicio;
    uint32_t tiempo_reaccion;
    uint32_t espera_random;

	while(1)
	{
		// 1. Apagar LEDs
		// FFFF en hexa equivale a 1111111111111111 en binario
		GPIOB_ODR &= ~(0xFFFF); // Apagar todo puerto B

		// 2. Espera aleatoria
		espera_random = (ms_count % 6000) + 4000; // Entre 4 y casi 10 segundos
			/* ms_count es una variable contador que aumenta cada 1ms debido al Systick. La variable tendra un valor diferente en cada
				pulsada debido al error humano de no tocar el boton siempre con el mismo retardo.
				Se divide por 6000 y se toma el resto, el cual será entre 0 y 5999. Para evitar que el valor de espera sea 0,
				se suman 4000 ms (4 segundos).*/
		tiempo_inicio = ms_count; // se guarda en la variable el tiempo de espera para no detener el proceso
        while((ms_count - tiempo_inicio) < espera_random); // Bloqueo hasta que pase el tiempo

		// 3. Encender LED rojo (esimulo)
		GPIOB_ODR |= (1 << 0);
		tiempo_inicio = ms_count; // Guardar el momento exacto en que prendió la luz

		// 4. POLLING: Esperar a que el usuario presione
        // (Se espera mientras el bit 0 sea 1, o sea, NO este presionado)
        while ((GPIOA_IDR & (1 << 0)) != 0);

		// 5. CALCULAR RESULTADO
        tiempo_reaccion = ms_count - tiempo_inicio;
        GPIOB_ODR &= ~(1 << 0); // Apagar estimulo

        if (tiempo_reaccion < 250) // Menos de 250ms es un tiempo de rta ACEPTABLE
        {
            GPIOB_ODR |= (1 << 1); // Prender VERDE (PB1)
        }
        else 
        {
            GPIOB_ODR |= (1 << 3); // Prender AMARILLO (PB3) es un tiempo de rta Lento
        }

        // 6. PAUSA PARA VER EL RESULTADO
        tiempo_inicio = ms_count;
        while((ms_count - tiempo_inicio) < 2000); // Esperar 2 segundos
    }

	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

// Tabla de vectores de interrupción: Primer bloque de memoria que lee el procesador al iniciar, esta al comienzo del Flash.
// Vector tables es un arreglo de punteros a funciones.
typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// Pos0. 0x0000_0000 Stack Pointer -> Valor inicial de donde arranca a leer el micro(pos 0 de la Flash)
	(interrupt_t) main,										// Pos1. 0x0000_0004 Reset
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    				// Posiciones 2 a 14 sin usar              
    [15] = SysTick_Handler,									// Posición 15: SysTick Handler
};
