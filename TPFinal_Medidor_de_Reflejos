typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

// Variables para la lógica
volatile uint32_t ms_count = 0; // Para contar tiempo

// RCC
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define APB2ENR *(volatile int*)0x40021018

// PUERTO A
#define GPIOA_CRL *(volatile int*)0x40010800
#define GPIOA_CRH *(volatile int*)0x40010804
#define GPIOA_ODR *(volatile int*)0x4001080C// lee y escribe en pines de salida -> no lo uso
#define GPIOA_IDR *(volatile int*)0x40010808 // lee y escribe en pines de entrada

// PUERTO B
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C // lee y escribe en pines de salida
#define GPIOB_IDR *(volatile int*)0x40010C08 // lee y escribe en pines de entrada -> no lo uso

// SYSTICK
#define SYSTICK_CSR  *(volatile int*)0xE000E010 // habilitar, deshabilitar y verificar el estado del temporizador
#define SYSTICK_RVR  *(volatile int*)0xE000E014 // almacena el valor desde el cual el temporizador SysTick comenzará a contar hacia abajo.
#define SYSTICK_CVR  *(volatile int*)0xE000E018 // almacena el valor actual del contador.
#define SYSTICK_CALIB  *(volatile int*)0xE000E01C // Registro de Valor Actual.

// Timer (cada 1ms)
void SysTick_Handler(void) 
{
	ms_count++;
}

int main(void)
{

	// 1. Relojes
	APB2ENR |= (1 << 2) | (1 << 3); // Enable GPIOA y GPIOB clock

	// 2. Configuracion GPIO
	// a) GPIOB como salida push-pull
	GPIOB_CRL  = 0x33333333;            // Make low GPIOB output (PB0, PB1, PB5)
	GPIOB_CRH  = 0x33333333;            // Make high GPIOB output -> no lo uso
	GPIOB_ODR &= ~(0xFFFF); 			// Asegurar que todo arranca apagado	
	
	// b) GPIOA como entrada pull-up
	// 0x8 en binario -> 1000 (Mode=00 Input, CNF=10 Pull-up/down)
	GPIOA_CRL  = 0x88888888;            // Make low GPIOC input 
	GPIOA_CRH  = 0x88888888;            // Make high GPIOC input -> no lo uso
	GPIOA_ODR |= (1 << 0);              // Activar Pull-Up en PA0 

	// 3. Configuración del Systick
	// Genera una interrupción cada 1ms
	SYSTICK_RVR = 7999;  // (8000 - 1)
    SYSTICK_CVR = 0;     // Reiniciar contador
	SYSTICK_CSR = 0x07; // 1 | 2 | 4 = 7 -> 0x07
							// Bit 0: ENABLE (1)
							// Bit 1: TICKINT (1) -> Habilita la interrupción
							// Bit 2: CLKSOURCE (1) -> Reloj del procesador

	uint32_t tiempo_inicio;
	uint32_t tiempo_reaccion;
	uint32_t espera_random;

	while(1)
	{
		// 1. Apagar LEDs
		// FFFF en hexa equivale a 1111111111111111 en binario
		GPIOB_ODR &= ~(0xFFFF); // Apagar todo puerto B

		// 2. Espera aleatoria
		espera_random = (ms_count % 2000) + 1000; // Entre 4 y casi 10 segundos
			/* ms_count es una variable contador que aumenta cada 1ms debido al Systick. La variable tendra un valor diferente en cada
				pulsada debido al error humano de no tocar el boton siempre con el mismo retardo.
				Se divide por 6000 y se toma el resto, el cual será entre 0 y 5999. Para evitar que el valor de espera sea 0,
				se suman 4000 ms (4 segundos).*/
		
		// 3. Esperar 
        tiempo_inicio = ms_count; 
        while((ms_count - tiempo_inicio) < espera_random); 

		// 4. Encender estimulo (LED rojo PB0)
		GPIOB_ODR |= (1 << 0); // Se pone en 1 PB0
		tiempo_inicio = ms_count; // se almcaena el momento en que se prendió el LED

		// 5. Esperar a que se presione el botón (POLLING)
		// Esperar mientras PA0 sea 1 (No presionado)
        while ((GPIOA_IDR & (1 << 0)) != 0); // Al presionar el boton el pin se conecta a tierra y se lee 0

		// 6. Resultados
		tiempo_reaccion = ms_count - tiempo_inicio; // Se resta el valor actual del contador con el tiempo en el que se registró el encendido
		GPIOB_ODR &= ~(1 << 0); // Apagar rojo

		if (tiempo_reaccion < 250)
        {
            GPIOB_ODR |= (1 << 1); // VERDE (PB1) -> Rápido
        }
        else 
        {
            GPIOB_ODR |= (1 << 5); // AMARILLO (PB5) - Lento
        }

		// 6. Visualización de los resultados
		tiempo_inicio = ms_count;
        while((ms_count - tiempo_inicio) < 2000); // Ver luz por 2 segundos
	}		
	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

// Tabla de vectores de interrupción: Primer bloque de memoria que lee el procesador al iniciar, esta al comienzo del Flash.
// Vector tables es un arreglo de punteros a funciones.
typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// Pos0. 0x0000_0000 Stack Pointer -> Valor inicial de donde arranca a leer el micro(pos 0 de la Flash)
	(interrupt_t) main,										// Pos1. 0x0000_0004 Reset
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    				// Posiciones 2 a 14 sin usar              
    [15] = SysTick_Handler,									// Posición 15: SysTick Handler
};
