typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

#define APB2ENR *(volatile int*)0x40021018

// Puerto C
#define GPIOC_CRL *(volatile int*)0x40011000
#define GPIOC_CRH *(volatile int*)0x40011004
#define GPIOC_ODR *(volatile int*)0x4001100C // ODR: Guarda el estado de salida

// Puerto B
// Registros de control del reloj (RCC)
// El registro APB2ENR está en la dirección base del RCC más un offset de 0x18
#define GPIOB_CRL *(volatile int*)0x40010C00
#define GPIOB_CRH *(volatile int*)0x40010C04
#define GPIOB_ODR *(volatile int*)0x40010C0C 
#define GPIOB_IDR *(volatile int*)0x40010C08 // se utiliza para detectar el estado, lee el estado de la entrada 1(prendido) y 0 (apagado)

int main(void)
{

	APB2ENR |= (1 << 4);  // Enable clock GIOPC
	APB2ENR |= (1 << 3); // Enable clock GIOPB

	GPIOC_CRL  = 0x33333333;            // Make low GPIOC output
	GPIOC_CRH  = 0x33333333;            // Make high GPIOC output
	
	GPIOB_CRL  = 0x33333333;            // Make low GPIOC output
	GPIOB_CRH  = 0x33333333;            // Make high GPIOC output	


	for(;;)
	{
		if(GPIOB_ODR & (1 << 12) && GPIOB_ODR & (1 << 13))
		{
			// Si el pin está en ALTO (conectado a 3.3V), encendemos el LED (pin PC13 a 0).
            GPIOC_ODR &= ~(1 << 13);
			GPIOB_ODR &= ~(1 << 12);
		}
		else
		{
			// Si el pin está en BAJO (conectado a GND o flotando), apagamos el LED (pin PC13 a 1).
			GPIOC_ODR |= (1 << 13);
			GPIOB_ODR |= (1 << 12);
		}
	}

	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)		
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// 0x0000_0000 Stack Pointer
	(interrupt_t) main,										// 0x0000_0004 Reset
};
